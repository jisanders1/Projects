# Lox: Bytecode Implementation in C
Jaylon Sanders: CS 403
Dr. Yessick, University of Alabama

This folder containts the workings of a Lox interpreter via a virtual machine in C, which accepts bytecode from the compiler and executes it. I used the book [_Crafting Interpreters_](https://www.craftinginterpreters.com/) and modified the code slightly. These modifications often included changing names where I feel a more understandable name could be used, switching switch statements for if statements and vice-versa, and switching some for loops to while loops where applicable. I completed through Chapter 24 of out of 30 for the text, which means that all of basic functionality (function declarations and calls, variable declaations, scope, all boolean operators, control flow, and native functions) have been implemented, but not classes, closures, garbage collection, and inheritance.

I have run several test cases that were provided in the text, and also manually ran all applicable test cases found in the [books' repository](https://github.com/munificent/craftinginterpreters/tree/master/test). Any test cases involving classes, closures, and inheritance were ommitted because this lacking this functionality would cause a test to fail, rather than be useful. Any failed test cases will be mentioned in the [Issues](https://github.com/jisanders1/Projects/tree/main/Programming%20Languages%20(CS%20403)/clox#issues) section at the bottom of this readme, and all other test cases have passed on my own computer. If you would like to run test cases for yourself, follow the directions for [Compiling](https://github.com/jisanders1/Projects/tree/main/Programming%20Languages%20(CS%20403)/clox#compiling) and [Running](https://github.com/jisanders1/Projects/tree/main/Programming%20Languages%20(CS%20403)/clox#running), specify the path of the test cases in the ```Tests``` folder, and compare the output with the expected values listed in the comments of the test cases you ran. Test cases are grouped by the funtionality they test.

## Compiling
In order to run the program, you should first make sure that you have the ability to compile and run C code. If you are running a Linux based system, then there is a high chance that it is already installed on your computer. If you are using a Windows, you could install the MinGW compiler (for instructions to compile go [here](https://www.geeksforgeeks.org/installing-mingw-tools-for-c-c-and-changing-environment-variable/])) or another compiler of your choice, such as Cygwin. After this step, you should clone this repository to a directory of your choice.

Before you compile the program, you should verify which debug flags you wish to enable.
```
DEBUG_PRINT_CODE:

    Enables printing of the bytecode generated by the compiler. Functions will get their own sections along with the global level.

DEBUG_TRACE_EXECUTION:

Enables the printing of the call stack along with its values and each op code that resulted in that stack. 

WARNING: This debug flag can be quite verbose. The values your program outputs WILL be nested within the all of the output.
``` 
In order to enable the debug flags, un-comment the following lines of the file ```common.h```. If you do not wish to generate these extra output (this extra output could make it difficult to see the output of the REPL especially), leave them commented.
```
DEBUG_PRINT_CODE - Line 10
DEBUG_TRACE_EXECUTION - Line 14
```

For reference here is the content that each flag may output. There is one example of each, but the length and output with most likely vary from Lox program to Lox program.
1. ```DEBUG_PRINT_CODE``` with the ```function/recursion.lox``` test case
```
== fib ==
0000    2 GET_LOCAL_OP        1
0002    | CONSTANT_OP         0 '2'
0004    | LESS_OP
0005    | JUMP_IF_FALSE_OP    5 -> 15
0008    | POP_OP
0009    | GET_LOCAL_OP        1
0011    | RETURN_OP
0012    | JUMP_OP            12 -> 16
0015    | POP_OP
0016    3 GET_GLOBAL_OP       1 'fib'
0018    | GET_LOCAL_OP        1
0020    | CONSTANT_OP         2 '1'
0022    | SUBTRACT_OP
0023    | CALL_OP             1
0025    | GET_GLOBAL_OP       3 'fib'
0027    | GET_LOCAL_OP        1
0029    | CONSTANT_OP         4 '2'
0031    | SUBTRACT_OP
0032    | CALL_OP             1
0034    | ADD_OP
0035    | RETURN_OP
0036    4 NIL_OP
0037    | RETURN_OP
== <script> ==
0000    4 CONSTANT_OP         1 '<fn fib>'
0002    | DEFINE_GLOBAL_OP    0 'fib'
0004    6 GET_GLOBAL_OP       2 'fib'
0006    | CONSTANT_OP         3 '8'
0008    | CALL_OP             1
0010    | PRINT_OP
0011    7 NIL_OP
0012    | RETURN_OP
21

```

2. ```DEBUG_TRACE_EXECUTION``` with the ```operator/add.lox``` test case
```
Val Stack: [ <script> ]

0000    1 CONSTANT_OP         0 '123'
Val Stack: [ <script> ][ 123 ]

0002    | CONSTANT_OP         1 '456'
Val Stack: [ <script> ][ 123 ][ 456 ]

0004    | ADD_OP
Val Stack: [ <script> ][ 579 ]

0005    | PRINT_OP
579
Val Stack: [ <script> ]

0006    2 CONSTANT_OP         2 'str'
Val Stack: [ <script> ][ str ]

0008    | CONSTANT_OP         3 'ing'
Val Stack: [ <script> ][ str ][ ing ]

0010    | ADD_OP
Val Stack: [ <script> ][ string ]

0011    | PRINT_OP
string
Val Stack: [ <script> ]

0012    3 NIL_OP
Val Stack: [ <script> ][ nil ]

0013    | RETURN_OP
```
There are two options for compiling. One utilizes a makefile and the other utilizes the C compiler directly. If your setup has the capability to execute a makefile, all you need to do is enter the following into your terminal to compile the project:
```
make
```
The alternative method to compile directly reequires you to navigate to the ```Sources``` folder and enter (I would copy and paste if I were you) the following line of code to compile the source files. The executable will be output in the parent directory so your should navigate back to the ```clox``` directory.
```
gcc chunk.c debug.c main.c memory.c value.c vm.c compiler.c scanner.c object.c table.c -o ../clox
```
## Running
After you enter this command, the program sholud be compiled to an executable. In order to run the program, you should type invoke the executable file, which may end in ".exe" or ".out" for most. For Windows users, you should be able to type the following in the Command Prompt:
```
clox
```
or the following if using Cygwin:
```
./clox
```
This will launch the REPL (short for **_R_**eading a line of input, **_E_**valuating it, **_P_**rinting the result, then **_L_**ooping and repeating all four steps again) and allow a user to enter lines of code into the terminal and have their code executed. You can only enter a maximum of 1,024 characters per line. If you want to run code from a file, enter the following:
```
clox <filename>.lox
```
or if using Cygwin:
```
./clox <filename>.lox
```
If there is an error (attempting to open a non-existent file or directory, running out of memory, etc.), the program will report it. 

Currently, the program evaluates both normal and block statements. Additionally, the program can handle control flow, such as if-else statements, while loops, and for loops, These can involve both global and local variables. For example, you can run the clox program with a file that contains the following:
```
fun sum(a, b, c) {
    return a + b + c;
}

print 4 + sum(5, 6, 7);
```
This should output:

1. With only the ```DEBUG_TRACE_EXECUTION``` flag enabled:
```
Val Stack: [ <script> ]

0000    3 CONSTANT_OP         1 '<fn sum>'
Val Stack: [ <script> ][ <fn sum> ]

0002    | DEFINE_GLOBAL_OP    0 'sum'
Val Stack: [ <script> ]

0004    5 CONSTANT_OP         2 '4'
Val Stack: [ <script> ][ 4 ]

0006    | GET_GLOBAL_OP       3 'sum'
Val Stack: [ <script> ][ 4 ][ <fn sum> ]

0008    | CONSTANT_OP         4 '5'
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ]

0010    | CONSTANT_OP         5 '6'
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ][ 6 ]

0012    | CONSTANT_OP         6 '7'
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ][ 6 ][ 7 ]

0014    | CALL_OP             3
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ][ 6 ][ 7 ]

0000    2 GET_LOCAL_OP        1
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ][ 6 ][ 7 ][ 5 ]

0002    | GET_LOCAL_OP        2
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ][ 6 ][ 7 ][ 5 ][ 6 ]

0004    | ADD_OP
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ][ 6 ][ 7 ][ 11 ]

0005    | GET_LOCAL_OP        3
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ][ 6 ][ 7 ][ 11 ][ 7 ]

0007    | ADD_OP
Val Stack: [ <script> ][ 4 ][ <fn sum> ][ 5 ][ 6 ][ 7 ][ 18 ]

0008    | RETURN_OP
Val Stack: [ <script> ][ 4 ][ 18 ]

0016    | ADD_OP
Val Stack: [ <script> ][ 22 ]

0017    | PRINT_OP
22
Val Stack: [ <script> ]

0018    | NIL_OP
Val Stack: [ <script> ][ nil ]

0019    | RETURN_OP
```

2. With only the ```DEBUG_PRINT_CODE``` flag enabled:
```
== sum ==
0000    2 GET_LOCAL_OP        1
0002    | GET_LOCAL_OP        2
0004    | ADD_OP
0005    | GET_LOCAL_OP        3
0007    | ADD_OP
0008    | RETURN_OP
0009    3 NIL_OP
0010    | RETURN_OP
== <script> ==
0000    3 CONSTANT_OP         1 '<fn sum>'
0002    | DEFINE_GLOBAL_OP    0 'sum'
0004    5 CONSTANT_OP         2 '4'
0006    | GET_GLOBAL_OP       3 'sum'
0008    | CONSTANT_OP         4 '5'
0010    | CONSTANT_OP         5 '6'
0012    | CONSTANT_OP         6 '7'
0014    | CALL_OP             3
0016    | ADD_OP
0017    | PRINT_OP
0018    | NIL_OP
0019    | RETURN_OP
22
```

3. With no flags enabled:
```
22
```

In this case, the output value is more easy to spot, even with the debug flags on. However, in more complex programs, outputs can become hard to spot, especially with the ```DEBUG_TRACE_EXECUTION``` flag. Due to this, I would highley recommend you to disable the ```DEBUG_TRACE_EXECUTION``` flag for more clarity in outputs. The program should also handle reporting errors in statements or errors that are inside of statements. If you attempt to enter an expression and not an expression statement (ie, you are missing a semicolon) into the REPL, such as ```1 + 2```, the program outputs: ```[line 2] Error at end: Expect ';' after expression.```. Entering an expression statement and not assigning it to a variable will evaluate it, but the result will not be stored nor printed.

## Progresion
You can find a copy of my code after each chapter in the ```Progression``` folder. To run these, you should unzip them to a location outside of this folder and complete the instructions from the [Compiling](https://github.com/jisanders1/Projects/tree/main/Programming%20Languages%20(CS%20403)/clox#compiling) and [Running](https://github.com/jisanders1/Projects/tree/main/Programming%20Languages%20(CS%20403)/clox#running) sections above. 

Chapter 14 - Chunks of Bytecode:
- Added basic functionality for encoding constant and return operations, and for encoding constants and values.
- Separated source and header files into two separate directories.
- Added ```.gitignore``` to not track any executables generated by the user.

Chapter 15 - A Virtual Machine:
- Added arithmetic operators and the ability to evaluate expressions.
- Updated ```.gitignore``` to not track additional compilation side effects (such as ```clox.exe.stackdump```).
- Updated and added comments above functions and wtihin them to detail what is happening.
- Made some changes to the debugger to more easily associate what is happening in the stack with the op codes.

Chapter 16 - Scanning on Demand:
- Added a scanner file, ```scanner.c```, that scans in source code from a either a file or the REPL. The REPL is an interactive command line program that allows users to enter a line of code and have it evaluated and executed. 
- Updated ```.gitignore``` to not track any Lox or Text files. This is so the repository looks cleaner.
- Got rid of old main in order to suppport the REPL and file reading features.
- Tested with some of my own test cases to ensure that error were being caught (opening a non-existent file, scanning an unterminated string, etc.). 

Chapter 17 - Compiling Expression:
- Added the ability to evaluate expressions involving numbers and the basic operators (addition, subtraction, multiplication, division).
- Added a new debug flag to print the bytecodes generated by the compiler.
- Compiler now evaluates expressions instead of printing the tokens to the terminal.

Chapter 18 - Types of Values:
- Added the ability to evaluate boolean and nil operators and print them in the debuggers.
- Arithmetic and boolean operators can now be chained together.

Chapter 19 - Strings:
- Added the ability to use strings in expressions for concatenation and comparison, as well as a base object class that can be used for other functionality later on.
- Set up cleanup for the storage used by string objects, although there is no garbage collection at the moment so all strings stick around until the program ends.

Chapter 20 - Hash Tables:
- Added a hash table module in order to implement assignment, function declarations, and class declarations in later chapters.
- Changed the way equality is checked with strings, instead of stepping through each character in the string, hash codes are used instead.
- Ran a REPL checking for string equality to ensure that the output is still correct.

Chapter 21 - Global Variables:
- Added the ability to define and assign global variables.
- Added the ability to print statements. Print statements print a newline with them by default.
- Entering expressions no longer will work, you must use a statement and follow it with a ';'.
- Tested the examples from this chapter through running a file with the test cases listed above in the [Running](https://github.com/jisanders1/Projects/tree/main/Programming%20Languages%20(CS%20403)/clox#running) section.

Chapter 22 - Local Variables:
- Added block statements with the ability to track the scope.
- With block statements, the differentiation between global and local variables was specified.
- Re-declaration of variables within the same scope and using a variable in its own initializer are not allowed.

Chapter 23 - Jumping Back and Forth:
- Added control flow to the program, including while loops, for loops, and if-else statements.
- Tested all of the different types of control flow with my own test cases.
- Decided that chapter 24 will be the last chapter that I am able to do for now due to time constraints.
- May consider showing a general example for how the debug flags look instead of providing 4 different version of the same program for each example.

Chapter 24 - Calls and Functions [FINAL CHAPTER FOR NOW]:
- Added the ability to declare and call functions in a Lox program.
- Tested with three of the test cases from this chapter in the book. Added these test cases to the [Running](https://github.com/jisanders1/Projects/tree/main/Programming%20Languages%20(CS%20403)/clox#running) section above.
- Tested with applicable test cases from the books' repository.
- Added a makefile.
- Added applicable test cases to the project in the ```Tests``` folder.
- Updated ```.gitignore``` to encompass more files that should not need to be tracked.

## Issues
- Changing the books code is slightly difficult due to how rigid C requires its declarations to be. Additionally, I have found switching switch statements to if-else statement negatively impacts readability completely. I will keep the original switch statements for most of the code.
- Recursion does not work inside of a block statement For example: running, ```local_recursion.lox``` in the ```test/function``` folder outputs the following code when it should output 21 (run ```recursion.lox``` and observe it outputs 21 correctly). This may be due to an issue when scope was implemented or this issue could have been resolved in a later chapter. This is not to say recursion does not work, it simply cannot be used inside of a block statement in this implementation.
```
Undefined variable 'fib'.
[line 4] in fib()
[line 7] in script
```
- Running ```decimal_point_at_eof.lox``` produces ```[line 2] Error at '.': Expect ';' after expression.``` instead of ```[line 2] Error at end: Expect property name after '.'.```, and this is also a similar case for running ```trailing_dot.lox```. Perhaps future chapters changed how errors are reported/caught, but at least an error is still reported.
- In running some of the longer test cases, it felt a bit slow. There is an optimization chapter that I did not get to so perhaps the speed could be improved in that chapter.