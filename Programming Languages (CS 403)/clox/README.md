# Lox: Bytecode Implementation in C
Jaylon Sanders: CS 403

This folder containts the workings of a Lox interpreter via a virtual machine in C. I used the book [_Crafting Interpreters_](https://www.craftinginterpreters.com/) and modified the code slightly. These modifications often included changing names where I feel a more understandable name could be used, switching switch statements for if statements and vice-versa, and switching some for loops to while loops where applicable. Additionally, I ran several test cases that were provided in the text, and will be running several of the test cases found in the [books' repository](https://github.com/munificent/craftinginterpreters/tree/master/test).

## Compiling
In order to run the program, you should first make sure that you have the ability to compile and run C code. If you are running a Linux based system, then there is a high chance that it is already installed on your computer. If you are using a Windows, you should install the MinGW compiler (for instructions to compile go [here](https://www.geeksforgeeks.org/installing-mingw-tools-for-c-c-and-changing-environment-variable/])). After this step, you should clone this repository to a directory of your choice.

Before you compile the program, you should verify which debug flags you wish to enable.
```
DEBUG_PRINT_CODE - Enables printing of the bytecode generated by the compiler
DEBUG_TRACE_EXECUTION - Enables the printing of the stack of values along with each op code.
``` 
In order to enable the debug flags, un-comment the following lines of the file ```common.h```. If you do not wish to generate these extra output (this extra output could make it difficult to see the output of the REPL especially), leave them commented.
```
DEBUG_PRINT_CODE - Line 10
DEBUG_TRACE_EXECUTION - Line 14
```

Finally, navigate to the ```Sources``` folder and enter the following line of code to compile the source files:
```
gcc main.c debug.c chunk.c memory.c value.c vm.c scanner.c compiler.c -o clox
```
## Running
After you enter this command, the program sholud be compiled to an executable. In order to run the program, you should type invoke the executable file, which may end in ".exe" or ".out" for most. For Windows users, you should be able to type the following in the Command Prompt:
```
clox
```
or the following if using Cygwin:
```
./clox
```
This will launch the REPL (short for **_R_**eading a line of input, **_E_**valuating it, **_P_**rinting the result, then **_L_**ooping and repeating all four steps again) and allow a user to enter lines of code into the terminal and have their code executed. You can only enter a maximum of 1,024 characters per line. If you want to run code from a file, enter the following:
```
clox <filename>.lox
```
or if using Cygwin:
```
./clox <filename>.lox
```
If there is an error (attempting to open a non-existent file or directory, running out of memory, etc.), the program will report it. 

Currently, the program evaluates one numeric/boolean expression in a similar manner to a calculator. The best method of testing this iteration of the program is utilizing the REPL in order to evaluate an different expression on each line in rapid sucession. For example: entering the ```!(5 - 4 > 3 * 2 == !nil)``` in the REPL should output:

1. With Both Flags enabled:
```
== code ==
0000    1 CONSTANT_OP         0 '5'
0002    | CONSTANT_OP         1 '4'
0004    | SUBTRACT_OP
0005    | CONSTANT_OP         2 '3'
0007    | CONSTANT_OP         3 '2'
0009    | MULTIPLY_OP
0010    | GREATER_OP
0011    | NIL_OP
0012    | NOT_OP
0013    | EQUAL_OP
0014    | NOT_OP
0015    2 RETURN_OP
Val Stack:

0000    1 CONSTANT_OP         0 '5'
Val Stack: [ 5 ]

0002    | CONSTANT_OP         1 '4'
Val Stack: [ 5 ][ 4 ]

0004    | SUBTRACT_OP
Val Stack: [ 1 ]

0005    | CONSTANT_OP         2 '3'
Val Stack: [ 1 ][ 3 ]

0007    | CONSTANT_OP         3 '2'
Val Stack: [ 1 ][ 3 ][ 2 ]

0009    | MULTIPLY_OP
Val Stack: [ 1 ][ 6 ]

0010    | GREATER_OP
Val Stack: [ false ]

0011    | NIL_OP
Val Stack: [ false ][ nil ]

0012    | NOT_OP
Val Stack: [ false ][ true ]

0013    | EQUAL_OP
Val Stack: [ false ]

0014    | NOT_OP
Val Stack: [ true ]

0015    2 RETURN_OP
true
```

2. With only the ```DEBUG_TRACE_EXECUTION``` flag enabled:
```
Val Stack:

0000    1 CONSTANT_OP         0 '5'
Val Stack: [ 5 ]

0002    | CONSTANT_OP         1 '4'
Val Stack: [ 5 ][ 4 ]

0004    | SUBTRACT_OP
Val Stack: [ 1 ]

0005    | CONSTANT_OP         2 '3'
Val Stack: [ 1 ][ 3 ]

0007    | CONSTANT_OP         3 '2'
Val Stack: [ 1 ][ 3 ][ 2 ]

0009    | MULTIPLY_OP
Val Stack: [ 1 ][ 6 ]

0010    | GREATER_OP
Val Stack: [ false ]

0011    | NIL_OP
Val Stack: [ false ][ nil ]

0012    | NOT_OP
Val Stack: [ false ][ true ]

0013    | EQUAL_OP
Val Stack: [ false ]

0014    | NOT_OP
Val Stack: [ true ]

0015    2 RETURN_OP
true
```

3. With only the ```DEBUG_PRINT_CODE``` flag enabled:
```
== code ==
0000    1 CONSTANT_OP         0 '5'
0002    | CONSTANT_OP         1 '4'
0004    | SUBTRACT_OP
0005    | CONSTANT_OP         2 '3'
0007    | CONSTANT_OP         3 '2'
0009    | MULTIPLY_OP
0010    | GREATER_OP
0011    | NIL_OP
0012    | NOT_OP
0013    | EQUAL_OP
0014    | NOT_OP
0015    2 RETURN_OP
true
```

4. With no flags enabled:
```
true
```

In all cases, the answer to the evaluation will be the last line of the output. The program should also handle reporting errors in expressions. For example, enterring ```*``` into the REPL should report the error ```[line 1] Error at '*': Expect expression.``` correctly.

## Progresion
You can find a copy of my code after each chapter in the ```Progression``` folder. To run these, you should unzip them to a location outside of this folder and complete the instructions fro running above.

Chapter 14 - Chunks of Bytecode:
- Added basic functionality for encoding constant and return operations, and for encoding constants and values.
- Separated source and header files into two separate directories.
- Added ```.gitignore``` to not track any executables generated by the user.

Chapter 15 - A Virtual Machine:
- Added arithmetic operators and the ability to evaluate expressions.
- Updated ```.gitignore``` to not track additional compilation side effects (such as ```clox.exe.stackdump```).
- Updated and added comments above functions and wtihin them to detail what is happening.
- Made some changes to the debugger to more easily associate what is happening in the stack with the op codes.

Chapter 16 - Scanning on Demand:
- Added a scanner file, ```scanner.c```, that scans in source code from a either a file or the REPL. The REPL is an interactive command line program that allows users to enter a line of code and have it evaluated and executed. 
- Updated ```.gitignore``` to not track any Lox or Text files. This is so the repository looks cleaner.
- Got rid of old main in order to suppport the REPL and file reading features.
- Tested with some of my own test cases to ensure that error were being caught (opening a non-existent file, scanning an unterminated string, etc.). 

Chapter 17 - Compiling Expression:
- Added the ability to evaluate expressions involving numbers and the basic operators (addition, subtraction, multiplication, division).
- Added a new debug flag to print the bytecodes generated by the compiler.
- Compiler now evaluates expressions instead of printing the tokens to the terminal.

Chapter 18 - Types of Values:
- Added the ability to evaluate boolean and nil operators and print them in the debuggers.
- Arithmetic and boolean operators can now be chained together.

## Issues
- The compilation process is a bit long. Perhaps making a makefile will reduce difficulty. 